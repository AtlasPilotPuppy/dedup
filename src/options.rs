#[cfg(feature = "proto")]
pub mod proto {
    // This will be generated by prost when the proto feature is enabled
    include!(concat!(env!("OUT_DIR"), "/dedups.rs"));
}

use crate::file_utils::{SortCriterion, SortOrder};
use crate::media_dedup::MediaDedupOptions;
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::str::FromStr;

/// The unified options structure that can be used across CLI, config, and protocol.
/// This provides a single source of truth for all configuration options.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DedupOptions {
    // Basic options
    pub directories: Vec<PathBuf>,
    pub target: Option<PathBuf>,
    pub deduplicate: bool,
    pub delete: bool,
    pub move_to: Option<PathBuf>,
    pub log: bool,
    pub log_file: Option<PathBuf>,
    pub output: Option<PathBuf>,
    pub format: String,
    pub json: bool,
    pub algorithm: String,
    pub parallel: Option<usize>,
    pub mode: String,
    pub interactive: bool,
    pub verbose: u8,
    pub include: Vec<String>,
    pub exclude: Vec<String>,
    pub filter_from: Option<PathBuf>,
    pub progress: bool,
    pub progress_tui: bool,
    pub sort_by: String,
    pub sort_order: String,
    pub raw_sizes: bool,
    pub config_file: Option<PathBuf>,
    pub dry_run: bool,
    pub cache_location: Option<PathBuf>,
    pub fast_mode: bool,

    // Media options
    pub media_mode: bool,
    pub media_resolution: String,
    pub media_formats: Vec<String>,
    pub media_similarity: u32,
    pub media_dedup_options: MediaDedupOptions,

    // SSH options
    #[cfg(feature = "ssh")]
    pub allow_remote_install: bool,
    #[cfg(feature = "ssh")]
    pub ssh_options: Vec<String>,
    #[cfg(feature = "ssh")]
    pub rsync_options: Vec<String>,
    #[cfg(feature = "ssh")]
    pub use_remote_dedups: bool,
    #[cfg(feature = "ssh")]
    pub use_sudo: bool,
    #[cfg(feature = "ssh")]
    pub use_ssh_tunnel: bool,
    #[cfg(feature = "ssh")]
    pub server_mode: bool,
    #[cfg(feature = "ssh")]
    pub port: u16,

    // Protocol options
    #[cfg(feature = "proto")]
    pub use_protobuf: bool,
    #[cfg(feature = "proto")]
    pub use_compression: bool,
    #[cfg(feature = "proto")]
    pub compression_level: u32,
}

impl Default for DedupOptions {
    fn default() -> Self {
        Self {
            directories: Vec::new(),
            target: None,
            deduplicate: false,
            delete: false,
            move_to: None,
            log: false,
            log_file: None,
            output: None,
            format: "json".to_string(),
            json: false,
            algorithm: "xxhash".to_string(),
            parallel: None,
            mode: "newest_modified".to_string(),
            interactive: false,
            verbose: 0,
            include: Vec::new(),
            exclude: Vec::new(),
            filter_from: None,
            progress: false,
            progress_tui: false,
            sort_by: "modified".to_string(),
            sort_order: "descending".to_string(),
            raw_sizes: false,
            config_file: None,
            dry_run: false,
            cache_location: None,
            fast_mode: false,

            // Media options
            media_mode: false,
            media_resolution: "highest".to_string(),
            media_formats: Vec::new(),
            media_similarity: 90,
            media_dedup_options: MediaDedupOptions::default(),

            // SSH options
            #[cfg(feature = "ssh")]
            allow_remote_install: true,
            #[cfg(feature = "ssh")]
            ssh_options: Vec::new(),
            #[cfg(feature = "ssh")]
            rsync_options: Vec::new(),
            #[cfg(feature = "ssh")]
            use_remote_dedups: true,
            #[cfg(feature = "ssh")]
            use_sudo: false,
            #[cfg(feature = "ssh")]
            use_ssh_tunnel: true,
            #[cfg(feature = "ssh")]
            server_mode: false,
            #[cfg(feature = "ssh")]
            port: 0,

            // Protocol options
            #[cfg(feature = "proto")]
            use_protobuf: true,
            #[cfg(feature = "proto")]
            use_compression: true,
            #[cfg(feature = "proto")]
            compression_level: 18,
        }
    }
}

impl DedupOptions {
    // Convert sort_by string to SortCriterion enum
    pub fn get_sort_criterion(&self) -> Result<SortCriterion> {
        SortCriterion::from_str(&self.sort_by)
    }

    // Convert sort_order string to SortOrder enum
    pub fn get_sort_order(&self) -> Result<SortOrder> {
        SortOrder::from_str(&self.sort_order)
    }

    // Convert to protobuf format if proto feature is enabled
    #[cfg(feature = "proto")]
    pub fn to_proto(&self) -> self::proto::DedupOptions {
        use self::proto;

        proto::DedupOptions {
            directories: self
                .directories
                .iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect(),
            target: self
                .target
                .as_ref()
                .map(|p| p.to_string_lossy().to_string()),
            deduplicate: self.deduplicate,
            delete: self.delete,
            move_to: self
                .move_to
                .as_ref()
                .map(|p| p.to_string_lossy().to_string()),
            json: self.json,
            algorithm: self.algorithm.clone(),
            parallel: self.parallel.map(|p| p as u32),
            mode: self.mode.clone(),
            interactive: self.interactive,
            verbose: self.verbose as u32,
            include: self.include.clone(),
            exclude: self.exclude.clone(),
            filter_from: self
                .filter_from
                .as_ref()
                .map(|p| p.to_string_lossy().to_string()),
            progress: self.progress,
            sort_by: self.sort_by.clone(),
            sort_order: self.sort_order.clone(),
            raw_sizes: self.raw_sizes,
            dry_run: self.dry_run,
            cache_location: self
                .cache_location
                .as_ref()
                .map(|p| p.to_string_lossy().to_string()),
            fast_mode: self.fast_mode,

            // Media options
            media_mode: self.media_mode,
            media_resolution: self.media_resolution.clone(),
            media_formats: self.media_formats.clone(),
            media_similarity: self.media_similarity,

            // SSH options
            allow_remote_install: self.allow_remote_install,
            ssh_options: self.ssh_options.clone(),
            rsync_options: self.rsync_options.clone(),
            use_remote_dedups: self.use_remote_dedups,
            use_sudo: self.use_sudo,
            use_ssh_tunnel: self.use_ssh_tunnel,
            server_mode: self.server_mode,
            port: self.port as u32,

            // Protocol options
            use_protobuf: self.use_protobuf,
            use_compression: self.use_compression,
            compression_level: self.compression_level,
        }
    }

    // Convert from protobuf format if proto feature is enabled
    #[cfg(feature = "proto")]
    pub fn from_proto(proto_opts: &self::proto::DedupOptions) -> Self {
        Self {
            directories: proto_opts
                .directories
                .iter()
                .map(|s| PathBuf::from(s))
                .collect(),
            target: proto_opts.target.as_ref().map(PathBuf::from),
            deduplicate: proto_opts.deduplicate,
            delete: proto_opts.delete,
            move_to: proto_opts.move_to.as_ref().map(PathBuf::from),
            log: false,     // Not needed in protocol
            log_file: None, // Not needed in protocol
            output: None,   // Not needed in protocol
            format: proto_opts.algorithm.clone(),
            json: proto_opts.json,
            algorithm: proto_opts.algorithm.clone(),
            parallel: proto_opts.parallel.map(|p| p as usize),
            mode: proto_opts.mode.clone(),
            interactive: proto_opts.interactive,
            verbose: proto_opts.verbose as u8,
            include: proto_opts.include.clone(),
            exclude: proto_opts.exclude.clone(),
            filter_from: proto_opts.filter_from.as_ref().map(PathBuf::from),
            progress: proto_opts.progress,
            progress_tui: false, // Not needed in protocol
            sort_by: proto_opts.sort_by.clone(),
            sort_order: proto_opts.sort_order.clone(),
            raw_sizes: proto_opts.raw_sizes,
            config_file: None, // Not needed in protocol
            dry_run: proto_opts.dry_run,
            cache_location: proto_opts.cache_location.as_ref().map(PathBuf::from),
            fast_mode: proto_opts.fast_mode,

            // Media options
            media_mode: proto_opts.media_mode,
            media_resolution: proto_opts.media_resolution.clone(),
            media_formats: proto_opts.media_formats.clone(),
            media_similarity: proto_opts.media_similarity,
            media_dedup_options: MediaDedupOptions::default(), // We'll update this separately

            // SSH options
            #[cfg(feature = "ssh")]
            allow_remote_install: proto_opts.allow_remote_install,
            #[cfg(feature = "ssh")]
            ssh_options: proto_opts.ssh_options.clone(),
            #[cfg(feature = "ssh")]
            rsync_options: proto_opts.rsync_options.clone(),
            #[cfg(feature = "ssh")]
            use_remote_dedups: proto_opts.use_remote_dedups,
            #[cfg(feature = "ssh")]
            use_sudo: proto_opts.use_sudo,
            #[cfg(feature = "ssh")]
            use_ssh_tunnel: proto_opts.use_ssh_tunnel,
            #[cfg(feature = "ssh")]
            server_mode: proto_opts.server_mode,
            #[cfg(feature = "ssh")]
            port: proto_opts.port as u16,

            // Protocol options
            #[cfg(feature = "proto")]
            use_protobuf: proto_opts.use_protobuf,
            #[cfg(feature = "proto")]
            use_compression: proto_opts.use_compression,
            #[cfg(feature = "proto")]
            compression_level: proto_opts.compression_level,
        }
    }
}
